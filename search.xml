<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mybatis-Plus]]></title>
    <url>%2FMybatis-Plus%2F</url>
    <content type="text"><![CDATA[JPA Mybatis MyBatis-Plus Demo MyBatis vs JPAJPA简介Java持久化规范 JPA的底层实现是一些流行的开源ORM(对象关系映射)框架，因此JPA其实也就是java实体对象和关系型数据库建立起映射关系，通过面向对象编程的思想操作关系型数据库的规范。 JPA是sun提出的一个对象持久化规范，各JavaEE应用服务器自主选择具体实现，JPA的设计者是Hibernate框架的作者，因此Hibernate作为Jboss服务器中JPA的默认实现，Oracle的Weblogic使用EclipseLink(以前叫TopLink)作为默认的JPA实现，IBM的Websphere和Sun的Glassfish默认使用OpenJPA(Apache的一个开源项目)作为其默认的JPA实现。 Mybatis优势 SQL语句可以自由控制，更灵活，性能较高 SQL与代码分离，易于阅读和维护 提供XML标签，支持编写动态SQL语句 JPA优势 JPA移植性比较好（JPQL） 提供了很多CRUD方法，开发效率高 对象化程度更高 MyBatis劣势 简单CRUD操作还得写SQL语句 XML中有大量的SQL要维护 MyBatis自身功能很有限(但支持Plugin) MyBatis-Plus文档MyBatis-Plus文档 lombok插件介绍lombok插件，让代码更简洁 案例建库建表1234567891011121314151617181920212223242526show databases;# 建库 CREATE SCHEMA `mp` DEFAULT CHARACTER SET utf8;use mp;# 创建用户表CREATE TABLE user ( id BIGINT(20) PRIMARY KEY NOT NULL COMMENT '主键', name VARCHAR(30) DEFAULT NULL COMMENT '姓名', age INT(11) DEFAULT NULL COMMENT '年龄', email VARCHAR(50) DEFAULT NULL COMMENT '邮箱', manager_id BIGINT(20) DEFAULT NULL COMMENT '直属上级id', create_time DATETIME DEFAULT NULL COMMENT '创建时间', CONSTRAINT manager_fk FOREIGN KEY (manager_id) REFERENCES user (id)) ENGINE=INNODB CHARSET=UTF8;show tables;# 查看表结构desc user;describe user;show columns from user;explain user; 创建maven项目1234567891011121314151617181920212223242526272829303132333435363738&lt;!--Spring Boot Starter 父工程--&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;!--Spring Boot启动器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--Spring Boot test启动器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--lombok简化java代码--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!--MyBatis-Plus启动器--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--MySQL jdbc驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 配置Spring Boot创建application.ymlapplication.yml123456spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/mp?useSSL=false&amp;serverTimezone=GMT%2B8 username: root password: root 编写实体类创建包 entity创建JAVA文件 User.java1234567891011121314151617181920package com.wenyd.mp.entity;import lombok.Data;import java.time.LocalDateTime;@Datapublic class User &#123; //主键 private Long id; //姓名 private String name; //年龄 private Integer age; //邮箱 private String email; //直属上级 private Long managerId; //创建时间 private LocalDateTime createTime;&#125; lombok可以在启动时动态生成Getter和Setter方法，因此不需要手动实现，这样可以避免属性名更改后忘记改Getter和Setter句柄导致的错误。 编写DAO创建包 dao创建JAVA文件 UserMapper.java 123456package com.wenyd.mp.dao;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.wenyd.mp.entity.User;public interface UserMapper extends BaseMapper&lt;User&gt; &#123; &#125; 继承BaseMapper类后可获得Mybatis-Plus提供的很多方法。 编写Application启动类创建JAVA文件 Application.java 12345678910111213package com.wenyd.mp;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication@MapperScan("com.wenyd.mp.dao")public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 注解@MapperScan(“com.wenyd.mp.dao”)会自动是扫描com.wenyd.mp.dao包下的Mapper。 编写测试类创建JAVA文件 SimpleTest.java 123456789101112131415161718192021222324252627package com.wenyd.mp;import com.wenyd.mp.dao.UserMapper;import com.wenyd.mp.entity.User;import org.junit.Assert;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import java.util.List;@RunWith(SpringRunner.class)@SpringBootTestpublic class SimpleTest &#123; @Autowired private UserMapper userMapper; @Test public void select() &#123; List&lt;User&gt; list = userMapper.selectList(null); Assert.assertEquals(4,list.size()); list.forEach(System.out::println); &#125;&#125; 注解 @RunWith(SpringRunner.class) 可以使启动服务。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>JPA</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Netty入门]]></title>
    <url>%2FNetty%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[java IO通信 WebSocket netty特点：高性能事件驱动、异步非阻塞；基于NIO的客户端，服务器端编程框架；稳定性和伸缩性netty使用场景：高性能领域吧；多线程并发领域；异步通信领域 java IO通信 特点 IO类型 BIO通信 一个线程负责连接，一请求一应答，缺乏弹性伸缩能力。 阻塞同步的IO 伪异步IO通信 线程池负责连接，M请求N应答，线程池阻塞。 阻塞同步的IO NIO通信 缓冲区Buffer；通道Channel；多路复用器Selector。 非阻塞同步的IO AIO通信 连接注册读写事件和回调函数；读写方法异步；主动通知程序。 非阻塞异步IO 原生NIO epoll BUG 导致CPU空轮询NIO的epoll空轮询bug WebSocketH5协议规范；一种在单个TCP连接上进行全双工通信的协议；解决客户端与服务端实时通信而产生的技术。特点：节省通信开销；服务器主动传送数据给客户端；实时通信建立连接：1客户端发起握手请求 2服务端相应握手 3建立连接生命周期：打开事件 消息事件 错误事件 关闭时间关闭连接：服务器关闭底层TCP连接；客户端发起TCP Close Netty服务端实现存储工程的全局配置12345678910package com.wenyd.netty;import io.netty.channel.group.ChannelGroup;import io.netty.channel.group.DefaultChannelGroup;import io.netty.util.concurrent.GlobalEventExecutor;public class NettyConfig &#123; // 存储每一个客户端接入进来时的channel对象 public static ChannelGroup group = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);&#125; 接受/处理/响应客户端webSocket请求的核心业务处理类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120package com.wenyd.netty;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelFutureListener;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;import io.netty.handler.codec.http.*;import io.netty.handler.codec.http.websocketx.*;import io.netty.util.CharsetUtil;import java.util.Date;public class MyWebSocketHandler extends SimpleChannelInboundHandler&lt;Object&gt; &#123; private WebSocketServerHandshaker handshaker; private static final String WEB_SOCKET_URL = "ws://localhost:8888/websocket"; // 客户端与服务端创建连接的时时调用 @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; NettyConfig.group.add(ctx.channel()); System.out.println("客户端与服务端连接开启..."); &#125; // 客户端与服务端断开连接的时候调用 @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123; NettyConfig.group.remove(ctx.channel()); System.out.println("客户端与服务端连接关闭..."); &#125; // 服务端接受客户端发送过来的数据结束之后调用 @Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123; ctx.flush(); &#125; // 工程出现异常的时候调用 @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; cause.printStackTrace(); ctx.close(); &#125; /** * 服务端处理客户端webSocket请求的核心方法 */ protected void channelRead0(ChannelHandlerContext channelHandlerContext, Object msg) throws Exception &#123; if (msg instanceof FullHttpRequest) &#123; // 处理客户端向服务端发起的http握手请求的业务 handHttpRequest(channelHandlerContext, (FullHttpRequest) msg); &#125; else if (msg instanceof WebSocketFrame) &#123; // 处理webSocket连接业务 handWebSocketFrame(channelHandlerContext, (WebSocketFrame) msg); &#125; &#125; /** * 处理客户端与服务器端之间的webSocket业务 */ private void handWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame frame)&#123; // 判断是否是关闭webSocket的指令 if (frame instanceof CloseWebSocketFrame) &#123; handshaker.close(ctx.channel(), ((CloseWebSocketFrame) frame.retain())); &#125; // 判断是否是ping指令 if (frame instanceof PingWebSocketFrame) &#123; ctx.channel().write(new PongWebSocketFrame(frame.content().retain())); return; &#125; // 判断是否是二进制消息，如果是二进制消息，抛出异常 if (!(frame instanceof TextWebSocketFrame)) &#123; System.out.println("目前不支持二进制消息"); throw new RuntimeException("【"+ this.getClass().getName() +"】不支持消息"); &#125; // 返回应答消息 String request = ((TextWebSocketFrame) frame).text(); System.out.println("服务端接收到客户端的消息：" + request); TextWebSocketFrame tws = new TextWebSocketFrame( new Date().toString() + "[" + ctx.channel().id() + "]:" + request); // 群发，服务端向每一个连接的客户端群发消息 NettyConfig.group.writeAndFlush(tws); &#125; /** * 处理客户端向服务端发起http握手请求的业务 */ private void handHttpRequest(ChannelHandlerContext ctx, FullHttpRequest req) &#123; if (!req.getDecoderResult().isSuccess() || !("websocket".equals(req.headers().get("Upgrade")))) &#123; sendHttpResponse(ctx, req, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.BAD_REQUEST)); return; &#125; WebSocketServerHandshakerFactory wsFactory = new WebSocketServerHandshakerFactory( WEB_SOCKET_URL, null, false); handshaker = wsFactory.newHandshaker(req); if (handshaker == null) &#123; WebSocketServerHandshakerFactory.sendUnsupportedWebSocketVersionResponse(ctx.channel()); &#125; else &#123; handshaker.handshake(ctx.channel(),req); &#125; &#125; /** * 服务端向客户端响应消息 */ private void sendHttpResponse(ChannelHandlerContext ctx, FullHttpRequest req, DefaultFullHttpResponse res) &#123; if (res.getStatus().code()!=200) &#123; ByteBuf buf = Unpooled.copiedBuffer(res.getStatus().toString(), CharsetUtil.UTF_8); res.content().writeBytes(buf); buf.release(); &#125; // 服务端向客户端发送数据 ChannelFuture f = ctx.channel().writeAndFlush(res); if (res.getStatus().code()!=200)&#123; f.addListener(ChannelFutureListener.CLOSE); &#125; &#125;&#125; 初始化连接时候的各个组件12345678910111213141516package com.wenyd.netty;import io.netty.channel.ChannelInitializer;import io.netty.channel.socket.SocketChannel;import io.netty.handler.codec.http.HttpObjectAggregator;import io.netty.handler.codec.http.HttpServerCodec;import io.netty.handler.stream.ChunkedWriteHandler;public class MyWebSocketChannelHandler extends ChannelInitializer&lt;SocketChannel&gt; &#123; protected void initChannel(SocketChannel socketChannel) throws Exception &#123; socketChannel.pipeline().addLast("http-codec", new HttpServerCodec()); socketChannel.pipeline().addLast("aggregator", new HttpObjectAggregator(65536)); socketChannel.pipeline().addLast("http-chunked", new ChunkedWriteHandler()); socketChannel.pipeline().addLast("handler", new MyWebSocketHandler()); &#125;&#125; 程序的入口，负责启动应用1234567891011121314151617181920212223242526272829package com.wenyd.netty;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.Channel;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.nio.NioServerSocketChannel;public class Main &#123; public static void main(String[] args) &#123; EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workGroup = new NioEventLoopGroup(); try &#123; ServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workGroup); b.channel(NioServerSocketChannel.class); b.childHandler(new MyWebSocketChannelHandler()); System.out.println("服务端开启，等待客户端连接..."); Channel ch = b.bind(8888).sync().channel(); ch.closeFuture().sync(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 优雅的推出程序 bossGroup.shutdownGracefully(); workGroup.shutdownGracefully(); &#125; &#125;&#125; 客户端实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset = utf-8"/&gt; &lt;title&gt;WebSocket客户端&lt;/title&gt; &lt;script type="text/javascript"&gt; var socket; if (!window.WebSocket) &#123; window.WebSocket = window.MozWebSocket; &#125; if (window.WebSocket) &#123; socket = new WebSocket("ws://localhost:8888/websocket"); socket.onmessage = function (ev) &#123; var ta = document.getElementById("responseContent"); ta.value += ev.data + "\r\n"; &#125;; socket.onopen = function (ev) &#123; var ta = document.getElementById("responseContent"); ta.value = "该浏览器支持WebSocket，请进行操作\r\n"; &#125;; socket.onclose = function (ev) &#123; var ta = document.getElementById("responseContent"); ta.value = ""; ta.value = "WebSocket链接已经关闭\r\n"; &#125;; &#125; else &#123; alert("该浏览器不支持WebSocket！"); &#125; function send(message) &#123; if (!window.WebSocket) &#123; return; &#125; if (socket.readyState == WebSocket.OPEN) &#123; socket.send(message); &#125; else &#123; alert("WebSocket连接没有建立成功"); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form onsubmit="return false;"&gt; &lt;input type="text" name="message" value=""/&gt; &lt;br&gt;&lt;br&gt; &lt;input type="button" value="发送WebSocket请求消息" onclick="send(this.form.message.value)"/&gt; &lt;hr&gt; &lt;h3&gt;客户端接收到服务器端返回的应答消息&lt;/h3&gt; &lt;textarea id="responseContent" style="width: 1024px; height: 300px;"&gt;&lt;/textarea&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 测试]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>netty</tag>
        <tag>NIO</tag>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven]]></title>
    <url>%2FMaven%2F</url>
    <content type="text"></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>jar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础]]></title>
    <url>%2FJava%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础]]></title>
    <url>%2FPython%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于统计的分词实现]]></title>
    <url>%2F%E5%9F%BA%E4%BA%8E%E7%BB%9F%E8%AE%A1%E7%9A%84%E5%88%86%E8%AF%8D%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[统计分词的主要思想是把每个词看做是由字组成的，如果相连的字在不同文本中出现的次数越多，就证明这段相连的字很有可能就是一个词。 隐含马尔可夫模型（HMM） 隐含马尔可夫模型（HMM）是将分词作为字在句子中的序列标注任务来实现的。 基本思路是：每个字在构造一个特定词语时都占据着一个特定的位置即词位，一般采用四结构词位：B（词首），M（词中），E（词尾）和S（单独成词）。 其中，词位序列代表着HMM中不可见的隐藏状态序列，而训练集中的文本则为可见的观测序列。这样就变成了已知观测序列，求未知的隐藏序列的HMM问题。 HMM 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116class HMM: def __init__(self): # 词语状态标签 B-k*M-E(2个字及以上词语) S(1个字的词语) self.state_list = ['B', 'M', 'E', 'S'] self.start_probability = &#123;&#125; # 初始状态概率 self.trans_probability = &#123;&#125; # 转移概率 self.emit_probability = &#123;&#125; # 观测概率 def __load_corpus(self, file): with open(file, 'r', encoding='utf-8') as f: for l in f: # 将一行文本拆成词，按照词进行分析 text_list = l.strip().split() for text in text_list: if len(text) &gt; 0: word_list = [w for w in text] label_list = self.__make_label(text) assert len(word_list) == len(label_list) yield word_list, label_list @staticmethod def __make_label(text): if len(text) == 1: result = ['S'] else: result = ['B'] + ['M']*(len(text)-2) + ['E'] return result def train(self, corpus, model): state_num_dict = &#123;&#125; # 记录每种状态的总数，用来计算概率 start_num_dict = &#123;&#125; # 初始位置每种状态的数量 trans_num_dict = &#123;&#125; # 各种状态之间转移的数量 emit_num_dict = &#123;&#125; for state in self.state_list: state_num_dict[state] = 0 start_num_dict[state] = 0 trans_num_dict[state] = &#123;v: 0 for v in self.state_list&#125; emit_num_dict[state] = &#123;&#125; # 根据每个字的状态，统计数量 pre_state = 'B' for word_list, label_list in self.__load_corpus(corpus): for i, v in enumerate(label_list): state_num_dict[v] += 1 if i == 0: start_num_dict[v] += 1 trans_num_dict[pre_state][v] += 1 emit_num_dict[v][word_list[i]] = emit_num_dict[v].get(word_list[i], 0) + 1 pre_state = label_list[i] # print(sum(state_num_dict.values()), sum(start_num_dict.values())) # 根据数量 计算概率 初始状态概率 转移概率 观测概率 self.start_probability = &#123;k: v*1.0/sum(start_num_dict.values()) for k, v in start_num_dict.items()&#125; self.trans_probability = &#123;k: &#123;k1: v1*1.0/state_num_dict[k1] for k1, v1 in v.items()&#125; for k, v in trans_num_dict.items()&#125; self.emit_probability = &#123;k: &#123;k1: ((v1*1.0+1.0)/state_num_dict.get(k, 1.0)) for k1, v1 in v.items()&#125; for k, v in emit_num_dict.items()&#125; # 保存模型 with open(model, 'wb') as f: import pickle pickle.dump(self.start_probability, f) pickle.dump(self.trans_probability, f) pickle.dump(self.emit_probability, f) print("模型训练完成,保存在", model) print(self.start_probability) print(self.trans_probability) print(self.emit_probability) def __viterbi(self, text=""): O_ = text.strip() I_ = self.state_list A_ = self.trans_probability B_ = self.emit_probability pi_ = self.start_probability delta = [&#123;&#125; for _ in range(len(O_))] phi = [&#123;&#125; for _ in range(len(O_))] # 1.初始化 for i in I_: delta[0][i] = pi_[i]*B_[i].get(O_[0], 1.0) phi[0][i] = 'S' # 2.递推 for t in range(1, len(O_)): for i in I_: (delta[t][i], phi[t][i]) = max([(delta[t-1][j]*A_[j][i]*B_[i].get(O_[t], 1.0), j) for j in I_]) # 3.终止 P = [0]*len(O_) I = ['']*len(O_) P = [max([v for v in _delta.values()])for _delta in delta] i = delta[len(O_)-1] I[len(O_)-1] = max(i, key=i.get) # 4.最优路径回溯 for t in range(len(O_)-1, 0, -1): I[t-1] = phi[t][I[t]] return I def analyze(self, text, model): # 加载模型 with open(model, 'rb') as f: import pickle self.start_probability = pickle.load(f) self.trans_probability = pickle.load(f) self.emit_probability = pickle.load(f) label = self.__viterbi(text.strip()) for i, l in enumerate(label): if i != 0 and (l == 'B' or l == 'S'): print('/', end='') print(text[i], end='')if __name__ == '__main__': hmm = HMM() # hmm.train('pku_training.utf8.txt', 'hmm_model.pkl') # hmm.analyze("迈向充满希望的新世纪——一九九八年新年讲话", 'hmm_model.pkl') hmm.analyze("我去北京四维图新大厦的路上经过火车站和天安门广场。", 'hmm_model.pkl') 输出结果1我去/北京/四/维图/新/大厦/的/路/上/经过/火车/站/和/天/安门/广场。]]></content>
      <categories>
        <category>中文分词</category>
      </categories>
      <tags>
        <tag>HMM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vertbi算法]]></title>
    <url>%2FVertbi%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[维特比算法 代码实现 维特比算法 代码实现12345678910111213141516171819202122232425262728293031def __viterbi(): O_ = [0, 1, 0] I_ = [0, 1, 2] A_ = [[0.5, 0.2, 0.3], [0.3, 0.5, 0.2], [0.2, 0.3, 0.5]] B_ = [[0.5, 0.5], [0.4, 0.6], [0.7, 0.3]] pi_ = [0.2, 0.4, 0.4] delta = [&#123;&#125; for _ in range(len(O_))] phi = [&#123;&#125; for _ in range(len(O_))] # 1.初始化 for i in I_: delta[0][i] = pi_[i]*B_[i][O_[0]] phi[0][i] = 0 # 2.递推 for t in range(1, len(O_)): for i in I_: (delta[t][i], phi[t][i]) = max([(delta[t-1][j]*A_[j][i]*B_[i][O_[t]], j) for j in I_]) # 3.终止 P = [0]*len(O_) I = [0]*len(O_) P = [max([v for v in _delta.values()])for _delta in delta] i = delta[len(O_)-1] I[len(O_)-1] = max(i, key=i.get) # 4.最优路径回溯 for t in range(len(O_)-1, 0, -1): I[t-1] = phi[t][I[t]] print(I) # 输出[2, 2, 2]]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>维特比</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL相关]]></title>
    <url>%2FSQL%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[SQL的分类 SQL的分类（1）、数据库查询语句（DQL）简称：DQL，Data Query Language代表关键字：select （2）、数据库操作语言（DML）简称：DML，Data Manipulation Language代表关键字：insert、delete 、update增、删、改表中的数据 （3）、数据库定义语言（DDL）简称：DDL，Data Denifition Language代表关键字：create、drop、alter创建、删除、修改表的结构 （4）、事务控制语言（TCL）简称：TCL，Trasactional Control Language代表关键字：commit、rollback （5）、数据控制语言（DCL）简称：DCL，Data Control Language代表关键字：grant、revoke （6）、DML与DDL的区别是什么DML是修改数据库表中的数据，而DDL是修改数据中表的结构； 参考资料OceanBase CSDN Mysql表的定义&amp;&amp;SQL的分类]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java避坑]]></title>
    <url>%2FJava%E9%81%BF%E5%9D%91%2F</url>
    <content type="text"><![CDATA[记录一些Java编程的经验教训 自动拆装箱与缓存在Java 5中，在Integer的操作上引入了一个新功能来节省内存和提高性能。整型对象通过使用相同的对象引用实现了缓存和重用。 适用于整数值区间-128 至 +127。 只适用于自动装箱。使用构造函数创建对象不适用。 Java SE的自动拆装箱还提供了一个和缓存有关的功能，我们先来看以下代码，猜测一下输出结果：123456789101112131415161718public static void main(String... strings) &#123; Integer integer1 = 3; Integer integer2 = 3; if (integer1 == integer2) System.out.println("integer1 == integer2"); else System.out.println("integer1 != integer2"); Integer integer3 = 300; Integer integer4 = 300; if (integer3 == integer4) System.out.println("integer3 == integer4"); else System.out.println("integer3 != integer4"); &#125; 我们普遍认为上面的两个判断的结果都是false。虽然比较的值是相等的，但是由于比较的是对象，而对象的引用不一样，所以会认为两个if判断都是false的。在Java中，==比较的是对象应用，而equals比较的是值。所以，在这个例子中，不同的对象有不同的引用，所以在进行比较的时候都将返回false。奇怪的是，这里两个类似的if条件判断返回不同的布尔值。 上面这段代码真正的输出结果：(原因就和Integer中的缓存机制有关。) 12integer1 == integer2integer3 != integer4 我们只需要知道，当需要进行自动装箱时，如果数字在-128至127之间时，会直接使用缓存中的对象，而不是重新创建一个对象。 其中的javadoc详细的说明了缓存支持-128到127之间的自动装箱过程。最大值127可以通过-XX:AutoBoxCacheMax=size修改。 实际上这个功能在Java 5中引入的时候,范围是固定的-128 至 +127。后来在Java 6中，可以通过java.lang.Integer.IntegerCache.high设置最大值。 参考资料hollischuang GitHub To Be Top Javaer - Java工程师成神之路]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python避坑]]></title>
    <url>%2FPython%E9%81%BF%E5%9D%91%2F</url>
    <content type="text"><![CDATA[记录一些Python编程的经验教训 codecs.open和open的区别 Python3直接用open。 Python2.x下用codecs.open，特别是有中文的情况，然后也可以避免踩到2.6下面io.open的坑。 如果希望代码同时兼容Python2和Python3，那么推荐用codecs.open。 资料百度知道]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于规则的分词实现]]></title>
    <url>%2F%E5%9F%BA%E4%BA%8E%E8%A7%84%E5%88%99%E7%9A%84%E5%88%86%E8%AF%8D%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[最大匹配法（MM）实现案例 逆向最大匹配法（RMM） 实现案例 准备文件词典文件word.txt12345678910北京天安门四维图新大厦广场路上前往火车站公司经过 停用词文件stoplis.txt12345678@#￥%&amp;_=+ 最大匹配法（MM）实现案例最大匹配法 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import codecsclass MM: def __init__(self): self.dic = &#123;&#125; self.stoplis = &#123;&#125; self.load() self.max_chars = 0 # 遍历分词字典，获得最大分词长度 for key in self.dic: if len(key) &gt; self.max_chars: self.max_chars = len(key) # map写法 # self.max_chars = max(map(len, [x for x in self.dic])) def load(self): # 获得分词字典，存储为字典形式 f1 = codecs.open('words.txt', 'r', encoding='utf8') while 1: line = f1.readline() if len(line) == 0: break term = line.strip().replace('\r\n', '') # 去除字符串两侧的换行符，避免取最大分词长度时出差错 self.dic[term] = 1 f1.close # 获得停用词典，存储为字典形式 f2 = codecs.open('stoplis.txt', 'r', encoding='utf8') while 1: line = f2.readline() if len(line) == 0: break term = line.strip() self.stoplis[term] = 1 f2.close # 正向最大匹配分词算法 def analyze(self, chars): # 获得需要分词的文本，为字符串形式 # 去除字符串两侧的换行符，避免截词时出差错 chars = chars.strip().replace('\r\n', '') # 定义一个空列表来存储分词结果 words = [] n = 0 while n &lt; len(chars): matched = 0 for i in range(self.max_chars, 0, -1): s = chars[n:n + i] # 判断所截取字符串是否在分词词典和停用词典内 if s in self.dic: if s in self.stoplis: matched = 1 n = n + i break else: words.append(s) matched = 1 n = n + i break if s in self.stoplis: matched = 1 n = n + i break if not matched: words.append(chars[n]) n = n + 1 print("/".join(words))if __name__ == '__main__': mm = MM() mm.analyze("我去北京四维图新大厦的路上经过@火车站和@天安门广场。") 测试结果1我/去/北京/四维图新/大厦/的/路上/经过/火车站/和/天安门/广场/。 逆向最大匹配法（RMM） 实现案例逆向最大匹配法 实现代码python1234567891011121314151617181920212223242526272829303132333435363738394041424344class RMM: def __init__(self, word_dict, stop_dict): self.word_dict = word_dict self.stop_dict = stop_dict # 扫描窗口大小,由最大单词长度决定 self.window_max_size = self.__getMaxLen() def __getMaxLen(self): return max(map(len, [word for word in self.word_dict])) def analyze(self, text): result = [] index = len(text) # 判断位置 while index &gt; 0: # 判断位置从后向前移动，当位置太靠前时，窗口需要结合实际缩小 window_size = min(index, self.window_max_size) for size in range(window_size, 0, -1): piece = text[index-size: index] if piece in self.stop_dict: index = index - size + 1 piece = "-*-停止词-*-" break elif piece in self.word_dict: index = index - size + 1 break index = index - 1 result.append(piece) # 因为是从后向前切分的,保存结果顺序需要反转 result.reverse() return resultif __name__ == '__main__': words = set() stops = set() with open('words.txt', 'r') as f: for w in f: words.add(w.strip()) with open('stoplis.txt', 'r') as f: for w in f: stops.add(w.strip()) rmm = RMM(words, stops) res = rmm.analyze("我去北京四维图新大厦的路上经过@火车站和@天安门广场。") print("/".join([w for w in res if w != "-*-停止词-*-"])) 测试结果1我/去/北京/四维图新/大厦/的/路上/经过/火车站/和/天安门/广场/。]]></content>
      <categories>
        <category>中文分词</category>
      </categories>
      <tags>
        <tag>最大匹配法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RSA算法]]></title>
    <url>%2FRSA%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[RSA公钥加密算法是1977年由Ron Rivest、Adi Shamirh和LenAdleman在（美国麻省理工学院）开发的。RSA取名来自开发他们三者的名字。RSA是目前最有影响力的公钥加密算法，它能够抵抗到目前为止已知的所有密码攻击，已被ISO推荐为公钥数据加密标准。RSA算法基于一个十分简单的数论事实：将两个大素数相乘十分容易，但那时想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。 RSA加密的安全性人类已经分解的最大整数（232个十进制位，768个二进制位）。比它更大的因数分解，还没有被报道过，因此目前被破解的最长RSA密钥就是768位。而RSA加密一般使用1024位或者2048位，基本可以理解为不可破解 RSA加密解密原理 X-&gt;Y加密公式: $X^E{mod}N=Y$Y-&gt;X解密公式: $Y^D{mod}N=N$ 1. 将N和E封装成公钥，N和D封装成私钥2. N为两个不等质数的乘积3. E与φ(N) 互素（互为质数）4. D满足$D \times E \equiv 1({mod}φ(N))$ 即 $D \times E-1=k \times φ(N)$ 案例计算 选择两个不等质数p,q (实际密钥一般为1024位或2048位)p=61,q=53 计算乘积nn = p*q = 3233 (二进制110010100001，只有12位) 计算n的欧拉函数φ(n)φ(n) = φ(p)*φ(q)= (p-1)(q-1) = 3120 (质数的因子只有1和本身—一个质数p的欧拉函数等于p-1) 随机选择一个整数e，条件是1&lt; e &lt; φ(n)，且e与φ(n) 互质。取e = 17 (实际应用中，常常选择$2^16=65537$)。 计算e对于φ(n)的模反元素ded = 1 (mod φ(n)) 即 ed -1 = kφ(n)17d -1 = k3120 即 17d +3120k = 1 得 d = 2753 将n和e封装成公钥，n和d封装成私钥加密使用 (3233,17)，解密使用(3233,2723) 加密(‘a’=65) n = 3233,e = 17所有字符串都可以使用ascil码/unicode值来表示，假设一个字符 m = a，ascii码为65,需要满足 m &lt; n 对他进行加密m^e ≡ c (mod n),c为加密字符串(65^17)%3233 = c 得 c = 2790密码为 2790 解密(2790) n = 3233,d = 2723c^d ≡ m (mod n) 即可得到mm = (2790^2723) %3233 得 m = 65内容为65=’a’ RSA算法相关数学理论 互素|互为质数python12345678910111213141516'''定义法 生成质数'''def primes(start, stop): if start &lt; 2: start = 2 for i in range(start, stop+1): for j in range(2, i): if i % j == 0: break else: yield i# 0到200之间的素数for x in primes(0, 200): print(x) python123456789101112131415161718192021222324252627282930313233343536'''埃氏筛法 生成质数（1）先把1删除（现今数学界1既不是质数也不是合数）（2）读取队列中当前最小的数2，然后把2的倍数删去（3）读取队列中当前最小的数3，然后把3的倍数删去（4）读取队列中当前最小的数5，然后把5的倍数删去（5）如上所述直到需求的范围内所有的数均删除或读取'''# 生成一个奇数生成器。def odd_iter(): n = 1 while True: n = n + 2 yield n# 过滤掉n的倍数的数。def not_divisible(n): return lambda x: x % n &gt; 0# 获取当前序列的第一个元素，然后删除后面序列该元素倍数的数，然后构造新序列。def primes(): yield 2 it = odd_iter() while True: n = next(it) yield n it = filter(not_divisible(n), it)# 获取 start 到 stop 之间的素数。def printPrimes(start, stop): # start, stop = 10, 2000 for n in primes(): if n &gt; start and n &lt; stop: print(n, end=',') elif n &gt; stop: break 欧拉函数欧拉函数的定义：对正整数n，欧拉函数是少于或等于n的数中与n互质的数的数目。例如euler(8)=4，因为1,3,5,7均和8互质。Euler函数表达通式：euler(x)=x(1-1/p1)(1-1/p2)(1-1/p3)(1-1/p4)…(1-1/pn),其中p1,p2……pn为x的所有素因数，x是不为0的整数。euler(1)=1（唯一和1互质的数就是1本身）。欧拉公式的延伸：一个数的与其互质的数(&lt;n)的总和是euler(n)*n/2 根据Euler函数表达通式直接求法：python123456789101112131415# 直接求解欧拉函数def euler(n): res = n a = n i = 2 #i表示小于a的所有质数 while i*i &lt;= a: if a % i == 0: # 先进行除法是为了防止中间数据的溢出 res = res / i * (i-1) while a % i == 0: a /= i i += 1 if a &gt; 1: res = res / a * (a-1) return res 欧拉定理费尔马小定理 模反元素 扩展欧几里得算法辗转相除法 python123456# 辗转相除法求最大公因数def gcd(a, b): if b == 0: return a else: return gcd(b, a % b) 快速幂取模算法 java12345678910111213141516/** * 快速幂取模 计算 (a^b) %c */private static int quick(int a,int b,int c) &#123; int ans=1; //记录结果 a=a%c; //预处理，使得a处于c的数据范围之下 while(b!=0) &#123; if((b&amp;1)==1)&#123; //1即是0000000000000001，判断个位是否是1.如果b的二进制位是1，那么我们的结果是要参与运算的 ans=(ans*a)%c; &#125; b&gt;&gt;=1; //二进制的移位操作，相当于每次除以2，用二进制看，就是我们不断的遍历b的二进制位 a=(a*a)%c; //不断的加倍 &#125; return ans;&#125; 参考资料ab6326795 公钥，私钥和数字签名这样最好理解不会汪汪的猫咪 CSDN RSA加密的原理——为什么被公钥加密的可以被私钥解密？Warning 扩展欧几里得算法详解sortmin CSDN 欧拉函数的两种基本写法]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>公钥加密算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2FGit%2F</url>
    <content type="text"><![CDATA[生成秘钥、git暂存区 git安装配置相关生成秘钥1ssh-keygen -t rsa -C "youremail@example.com" git本地使用git stash切换其他分支前，暂存当前分支的修改12# 将当前工作区的暂存区的数据收入stashgit stash git stash 不会存储未跟踪的文件，所以使用该指令操作如下比较安全，执行stash后内容为最近commit节点内容。12345678910# 1.看有没有未追踪的文件git status# 2.如果有未追踪的文件，先addgit add .# 3.可暂存修改了git stash# 或git stash save '本次暂存的标识名字' 查看存储列表1git stash list 切换回分支后，恢复暂存的修改12345678910111213# 直接恢复最近的暂存，pop后暂存列表清空git stash popgit stash pop stash@&#123;0&#125;# 也有其他指令可以恢复,apply后暂存列表不清空git stash applygit stash apply stash@&#123;0&#125;# 手动清理暂存列表#删除某个暂存, 暂存记录保存在list内,需要通过list索引index取出恢复git stash drop stash@&#123;index&#125;#删除全部暂存git stash clear]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>经验</tag>
        <tag>git</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra算法]]></title>
    <url>%2FDijkstra%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。 序号 S集合 U集合 1 A=0 (A)B=6,(A)C=3,D=∞,E=∞,F=∞ 2 A=0,A-C=3 (C)B=5,(C)D=6,(C)E=7,F=∞ 3 A=0,A-C=3,A-C-B=5 (C)D=6,(C)E=7,F=∞ 4 A=0,A-C=3,A-C-B=5,A-C-D=6 (C)E=7,(D)F=9 5 A=0,A-C=3,A-C-B=5,A-C-D=6,A-C-E=7 (D)F=9 6 A=0,A-C=3,A-C-B=5,A-C-D=6,A-C-E=7,A-C-D-F=9 当U集合为空时，探索路径结束，A-F最短路径:A-C-D-F=9 S集合 已探索最短路径的顶点集合（记录最短路径和距离）U集合 未确定最短路径的顶点集合（记录短路径和距离） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class Dijkstra &#123; public static final int M = 10000; // 代表正无穷 public static String[] nodes = &#123;"A","B","C","D","E","F"&#125;; public static void main(String[] args) &#123; // 二维数组每一行分别是 A、B、C、D、E 各点到其余点的距离, // A -&gt; A 距离为0, 常量M 为正无穷 int[][] weight1 = &#123; &#123;0,6,3,M,M,M&#125;, &#123;6,0,2,5,M,M&#125;, &#123;3,2,0,3,4,M&#125;, &#123;M,5,3,0,2,3&#125;, &#123;M,M,4,2,0,5&#125;, &#123;M,M,M,3,5,0&#125;, &#125;; int start = 0; int[] shortPath = dijkstra(weight1, start); for (int i = 0; i &lt; shortPath.length; i++) System.out.println("从" + nodes[start] + "出发到" + nodes[i] + "的最短距离为：" + shortPath[i]); &#125; public static int[] dijkstra(int[][] weight, int start) &#123; // 接受一个有向图的权重矩阵，和一个起点编号start（从0编号，顶点存在数组中） // 返回一个int[] 数组，表示从start到它的最短路径长度 int n = weight.length; // 顶点个数 int[] shortPath = new int[n]; // 保存start到其他各点的最短路径 String[] path = new String[n]; // 保存start到其他各点最短路径的字符串表示 for (int i = 0; i &lt; n; i++) path[i] = new String(nodes[start] + "--&gt;" + nodes[i]); int[] visited = new int[n]; // 标记当前该顶点的最短路径是否已经求出,1表示已求出 // 初始化，第一个顶点已经求出 shortPath[start] = 0; visited[start] = 1; for (int count = 1; count &lt; n; count++) &#123; // 要加入n-1个顶点 int k = -1; // 选出一个距离初始顶点start最近的未标记顶点 int dmin = Integer.MAX_VALUE; for (int i = 0; i &lt; n; i++) &#123; if (visited[i] == 0 &amp;&amp; weight[start][i] &lt; dmin) &#123; dmin = weight[start][i]; k = i; &#125; &#125; // 将新选出的顶点标记为已求出最短路径，且到start的最短路径就是dmin shortPath[k] = dmin; visited[k] = 1; // 以k为中间点，修正从start到未访问各点的距离 for (int i = 0; i &lt; n; i++) &#123; //如果 '起始点到当前点距离' + '当前点到某点距离' &lt; '起始点到某点距离', 则更新 if (visited[i] == 0 &amp;&amp; weight[start][k] + weight[k][i] &lt; weight[start][i]) &#123; weight[start][i] = weight[start][k] + weight[k][i]; path[i] = path[k] + "--&gt;" + nodes[i]; &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; System.out.println("从" + nodes[start] + "出发到" + nodes[i] + "的最短路径为：" + path[i]); &#125; System.out.println("====================================="); return shortPath; &#125;&#125; 运行结果12345678910111213从A出发到A的最短路径为：A--&gt;A从A出发到B的最短路径为：A--&gt;C--&gt;B从A出发到C的最短路径为：A--&gt;C从A出发到D的最短路径为：A--&gt;C--&gt;D从A出发到E的最短路径为：A--&gt;C--&gt;E从A出发到F的最短路径为：A--&gt;C--&gt;D--&gt;F=====================================从A出发到A的最短距离为：0从A出发到B的最短距离为：5从A出发到C的最短距离为：3从A出发到D的最短距离为：6从A出发到E的最短距离为：7从A出发到F的最短距离为：9 迪杰斯特拉(Dijkstra)算法适用于路径距离大于0（权值&gt;0）的最短路径计算，对带负权的图，应该用Floyd算法。 参考资料殷天文 简书 深入理解 Dijkstra 算法实现原理heroacool CSDN 数据结构–Dijkstra算法最清楚的讲解]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分词原理]]></title>
    <url>%2F%E5%88%86%E8%AF%8D%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[英文中，一个单词就是一个词，而汉语中，以字为基本的书写单位，词语之间没有明显的区分标记，需要人为切分。根据其特点，可以把分词算法分为四大类： 基于规则的分词方法 基于统计的分词方法 基于语义的分词方法 基于理解的分词方法 基于规则的分词方法这种方法又叫作机械分词方法、基于字典的分词方法，它是按照一定的策略将待分析的汉字串与一个“充分大的”机器词典中的词条进行匹配。若在词典中找到某个字符串，则匹配成功。该方法有三个要素，即分词词典、文本扫描顺序和匹配原则。文本的扫描顺序有正向扫描、逆向扫描和双向扫描。匹配原则主要有最大匹配、最小匹配、逐词匹配和最佳匹配。 最大匹配法（MM）。基本思想是：假设自动分词词典中的最长词条所含汉字的个数为 i，则取被处理材料当前字符串序列中的前i个字符作为匹配字段，查找分词词典，若词典中有这样一个i字词，则匹配成功，匹配字段作为一个词被切分出来；若词典中找不到这样的一个i字词，则匹配失败，匹配字段去掉最后一个汉字，剩下的字符作为新的匹配字段，再进行匹配，如此进行下去，直到匹配成功为止。统计结果表明，该方法的错误率为 1/169. 逆向最大匹配法（RMM）。该方法的分词过程与 MM 法相同，不同的是从句子（或文章）末尾开始处理，每次匹配不成功时去掉的是前面的一个汉字。统计结果表明，该方法的错误率为 1/245。 逐词遍历法。把词典中的词按照由长到短递减的顺序逐字搜索整个待处理的材料，一直到把全部的词切分出来为止。不论分词词典多大，被处理的材料多么小，都得把这个分词词典匹配一遍。 设立切分标志法。切分标志有自然和非自然之分。自然切分标志是指文章中出现的非文字符号，如标点符号等；非自然标志是利用词缀和不构成词的词（包 括单音词、复音节词以及象声词等）。设立切分标志法首先收集众多的切分标志，分词时先找出切分标志，把句子切分为一些较短的字段，再用 MM、RMM 或其它的方法进行细加工。这种方法并非真正意义上的分词方法，只是自动分词的一种前处理方式而已，它要额外消耗时间扫描切分标志，增加存储空间存放那些非 自然切分标志。 最佳匹配法（OM）。此法分为正向的最佳匹配法和逆向的最佳匹配法，其出发点是：在词典中按词频的大小顺序排列词条，以求缩短对分词词典的检索时 间，达到最佳效果，从而降低分词的时间复杂度，加快分词速度。实质上，这种方法也不是一种纯粹意义上的分词方法，它只是一种对分词词典的组织方式。OM 法的分词词典每条词的前面必须有指明长度的数据项，所以其空间复杂度有所增加，对提高分词精度没有影响，分词处理的时间复杂度有所降低。 此种方法优点是简单，易于实现。但缺点有很多：匹配速度慢；存在交集型和组合型歧义切分问题；词本身没有一个标准的定义，没有统一标准的词集；不同词典产生的歧义也不同；缺乏自学习的智能性。 基于统计的分词方法该方法的主要思想：词是稳定的组合，因此在上下文中，相邻的字同时出现的次数越多，就越有可能构成一个词。因此字与字相邻出现的概率或频率能较好地反映成词的可信度。可以对训练文本中相邻出现的各个字的组合的频度进行统计，计算它们之间的互现信息。互现信息体现了汉字之间结合关系的紧密程度。当紧密程 度高于某一个阈值时，便可以认为此字组可能构成了一个词。该方法又称为无字典分词。该方法所应用的主要的统计模型有：N 元文法模型（N-gram）、隐马尔可夫模型（Hiden Markov Model，HMM）、最大熵模型（ME）、条件随机场模型（Conditional Random Fields，CRF）等。在实际应用中此类分词算法一般是将其与基于词典的分词方法结合起来，既发挥匹配分词切分速度快、效率高的特点，又利用了无词典分词结合上下文识别生词、自动消除歧义的优点。 基于语义的分词方法语义分词法引入了语义分析，对自然语言自身的语言信息进行更多的处理，如扩充转移网络法、知识分词语义分析法、邻接约束法、综合匹配法、后缀分词法、特征词库法、矩阵约束法、语法分析法等。 扩充转移网络法。该方法以有限状态机概念为基础。有限状态机只能识别正则语言，对有限状态机作的第一次扩充使其具有递归能力，形成递归转移网络 （RTN）。在RTN 中，弧线上的标志不仅可以是终极符（语言中的单词）或非终极符（词类），还可以调用另外的子网络名字分非终极符（如字或字串的成词条件）。这样，计算机在 运行某个子网络时，就可以调用另外的子网络，还可以递归调用。词法扩充转移网络的使用， 使分词处理和语言理解的句法处理阶段交互成为可能，并且有效地解决了汉语分词的歧义。 矩阵约束法。其基本思想是：先建立一个语法约束矩阵和一个语义约束矩阵， 其中元素分别表明具有某词性的词和具有另一词性的词相邻是否符合语法规则， 属于某语义类的词和属于另一词义类的词相邻是否符合逻辑，机器在切分时以之约束分词结果。 基于理解的分词方法基于理解的分词方法是通过让计算机模拟人对句子的理解，达到识别词的效果。其基本思想就是在分词的同时进行句法、语义分析，利用句法信息和语义信息来处理歧义现象。它通常包括三个部分：分词子系统、句法语义子系统、总控部分。在总控部分的协调下，分词子系统可以获得有关词、句子等的句法和语义信息来对分词歧义进行判断，即它模拟了人对句子的理解过程。这种分词方法需要使用大量的语言知识和信息。目前基于理解的分词方法主要有专家系统分词法和神经网络分词法等。 专家系统分词法。从专家系统角度把分词的知识（包括常识性分词知识与消除歧义切分的启发性知识即歧义切分规则）从实现分词过程的推理机中独立出来，使知识库的维护与推理机的实现互不干扰，从而使知识库易于维护和管理。它还具有发现交集歧义字段和多义组合歧义字段的能力和一定的自学习功能。 神经网络分词法。该方法是模拟人脑并行，分布处理和建立数值计算模型工作的。它将分词知识所分散隐式的方法存入神经网络内部，通过自学习和训练修改内部权值，以达到正确的分词结果，最后给出神经网络自动分词结果，如使用 LSTM、GRU 等神经网络模型等。 神经网络与专家系统结合分词法。该方法首先启动神经网络进行分词，当神经网络对新出现的词不能给出准确切分时，激活专家系统进行分析判断，依据知识库进行推理，得出初步分析，并启动学习机制对神经网络进行训练。该方法可以较充分发挥神经网络与专家系统二者优势，进一步提高分词效率。 参考资料Judikator 简书 中文分词原理及常用Python中文分词库介绍]]></content>
      <categories>
        <category>数学之美</category>
      </categories>
      <tags>
        <tag>分词</tag>
        <tag>原理</tag>
      </tags>
  </entry>
</search>
